<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>StraightBar Lite – Web</title>
<style>
  :root { color-scheme: dark; }
  body{margin:0;background:#0b0b0d;color:#ddd;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  header{padding:10px 14px;font-weight:600;display:flex;gap:10px;align-items:center;justify-content:space-between;background:#141419;border-bottom:1px solid #222}
  .stat{opacity:.9;font-size:.95rem;display:flex;gap:14px;flex-wrap:wrap}
  .wrap{padding:12px;display:flex;flex-direction:column;gap:12px;max-width:860px;margin:0 auto}
  .panel{background:#141419;border:1px solid #222;border-radius:12px;padding:16px}
  .big{font-size:52px;font-weight:800;letter-spacing:.5px}
  .hint{opacity:.8;margin-top:6px}
  .grid{background:#0f0f14;border-radius:12px;position:relative;height:260px;border:1px solid #222;overflow:hidden}
  canvas{position:absolute;inset:0}
  .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  button,input{font-size:16px;border-radius:10px;border:1px solid #2a2a2f;background:#1a1a22;color:#ddd;padding:10px 14px}
  button.primary{background:#2a5bff;border-color:#2a5bff;color:white}
  input[type="number"]{width:90px}
  .badge{border:1px solid #333;padding:6px 10px;border-radius:999px;font-size:.9rem}
  .ok{color:#19c37d}.warn{color:#f5a524}.bad{color:#ef4444}.muted{opacity:.7}
  .on{background:#19c37d;border-color:#19c37d;color:#0b0b0d}
</style>
</head>
<body>
<header>
  <div>StraightBar Lite – <span class="muted">Web</span></div>
  <div class="stat">
    <span id="statGps">GPS: -</span>
    <span id="statAcc">精度: -</span>
    <span id="statSpd">速度: -</span>
    <span id="statHead">針路: -</span>
    <span id="statAB" class="badge muted">A/B: 未設定</span>
    <span id="statABlen" class="badge muted">AB距離: -</span>
    <span id="statLog" class="badge muted">LOG: 0点</span>
  </div>
</header>

<div class="wrap">
  <!-- ガイダンス -->
  <div class="panel">
    <div style="display:flex;align-items:baseline;gap:14px;flex-wrap:wrap">
      <div id="dir" class="big">--</div>
      <div id="unit" style="font-size:22px;opacity:.85">m</div>
    </div>
    <div class="hint" id="sub">横ズレ: 0.00m / Aから: 0.0m / 沿線距離: 0.0m</div>
  </div>

  <!-- 可視化（中央固定線 + 可動線のみ） -->
  <div class="grid"><canvas id="vis"></canvas></div>

  <!-- 操作 -->
  <div class="panel">
    <div class="row">
      <button class="primary" id="btnStart">計測開始</button>
      <button id="btnStop">停止</button>
      <button id="btnWake">画面常時ON</button>
      <label>感度(gain):
        <input type="number" id="gain" value="2.0" step="0.1" />
      </label>
      <span id="stateBadge" class="badge muted">待機中</span>
    </div>
    <div class="row" style="margin-top:10px">
      <button id="btnA">A点 設定</button>
      <button id="btnB">B点 設定</button>
      <button id="btnClear">A/Bクリア</button>
      <button id="logToggle">ログ記録: OFF</button>
      <button id="logDownload">CSVダウンロード</button>
    </div>
  </div>
</div>
<script>
// ====== ユーティリティ ======
const R = 6378137;
function toRad(d){ return d*Math.PI/180; }
function ll2enu(lat, lon, lat0, lon0){
  // ENU近似（緯度で縮尺を補正）
  const dLat = (lat-lat0)*Math.PI/180;
  const dLon = (lon-lon0)*Math.PI/180;
  const mPerDegLat = Math.PI*R/180;
  const mPerDegLon = mPerDegLat*Math.cos(lat0*Math.PI/180);
  return [dLon*mPerDegLon, dLat*mPerDegLat]; // [e,n]
}
function haversine(lat1,lon1,lat2,lon2){
  const dLat=toRad(lat2-lat1), dLon=toRad(lon2-lon1);
  const s1=Math.sin(dLat/2), s2=Math.sin(dLon/2);
  const a=s1*s1 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*s2*s2;
  return 2*6371000*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}
function norm(v){ return Math.hypot(v[0],v[1]); }
function normalize(v){ const n=norm(v)||1; return [v[0]/n,v[1]/n]; }

// ====== 状態 ======
let watchId=null, ref=null, A_ll=null, B_ll=null, line=null;
let crossTrack=0, alongTrack=0;
let settingA=false, settingB=false;
let gain=2.0; // 入力と連動
let logging=false, log=[];

// ====== DOM取得 ======
const cvs = document.getElementById('vis');
const ctx = cvs.getContext('2d');
const stateBadge = document.getElementById('stateBadge');
const gainInp = document.getElementById('gain');

const statGps  = document.getElementById('statGps');
const statAcc  = document.getElementById('statAcc');
const statSpd  = document.getElementById('statSpd');
const statHead = document.getElementById('statHead');
const statAB   = document.getElementById('statAB');
const statABlen= document.getElementById('statABlen');
const statLog  = document.getElementById('statLog');

const dirEl = document.getElementById('dir');
const subEl = document.getElementById('sub');

const btnStart = document.getElementById('btnStart');
const btnStop  = document.getElementById('btnStop');
const btnWake  = document.getElementById('btnWake');
const btnA     = document.getElementById('btnA');
const btnB     = document.getElementById('btnB');
const btnClear = document.getElementById('btnClear');
const btnLogToggle = document.getElementById('logToggle');
const btnLogDownload = document.getElementById('logDownload');

// ====== 画面描画 ======
function resize(){ cvs.width = cvs.clientWidth; cvs.height = cvs.clientHeight; draw(); }
window.addEventListener('resize', resize); resize();

function draw(){
  const w=cvs.width, h=cvs.height;
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle='#0f0f14'; ctx.fillRect(0,0,w,h);

  // 薄い縦ガイド
  ctx.strokeStyle='#202028'; ctx.lineWidth=1;
  for(let i=0;i<6;i++){ const x=i*w/6; ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }

  // 中央固定線（水色・太め）
  const cx = w/2;
  ctx.strokeStyle='#38bdf8'; ctx.lineWidth=6;
  ctx.beginPath(); ctx.moveTo(cx,0); ctx.lineTo(cx,h); ctx.stroke();

  // 可動線（横ズレ×感度）
  if(line){
    let moveX = cx + crossTrack*gain*(w/(6*2)); // 片側6mを基準に可視化
    moveX = Math.max(0, Math.min(w, moveX));
    const absE=Math.abs(crossTrack);
    const color = absE<=0.10 ? '#19c37d' : (absE<=0.30 ? '#f5a524' : '#ef4444'); // 10cm/30cm
    ctx.strokeStyle=color; ctx.lineWidth=10;
    ctx.beginPath(); ctx.moveTo(moveX,0); ctx.lineTo(moveX,h); ctx.stroke();
  }
}

// ====== UI更新 ======
function updateHeader({gpsOn,acc,spd,head}){
  statGps.textContent  = gpsOn ? 'GPS: 取得中' : 'GPS: -';
  statAcc.textContent  = '精度: ' + (acc==null? '-' : `${acc.toFixed(0)}m`);
  statSpd.textContent  = '速度: ' + (spd ? (spd*3.6).toFixed(1)+'km/h' : '-');
  statHead.textContent = '針路: ' + (head==null? '-' : `${head.toFixed(0)}°`);

  if(settingA){ statAB.textContent='A/B: A点設定中'; statAB.className='badge warn'; }
  else if(settingB){ statAB.textContent='A/B: B点設定中'; statAB.className='badge warn'; }
  else if(line){ statAB.textContent='A/B: 設定済'; statAB.className='badge ok'; }
  else if(A_ll){ statAB.textContent='A/B: Aのみ設定'; statAB.className='badge'; }
  else { statAB.textContent='A/B: 未設定'; statAB.className='badge muted'; }

  const abLen = (A_ll && B_ll) ? `${haversine(A_ll.lat,A_ll.lon,B_ll.lat,B_ll.lon).toFixed(1)} m` : '-';
  statABlen.textContent = 'AB距離: ' + abLen;

  statLog.textContent = `LOG: ${log.length}点`;
  statLog.className = 'badge ' + (logging ? 'ok' : 'muted');

  // 大表示
  const sign = crossTrack>0?'左へ':(crossTrack<0?'右へ':'そのまま');
  dirEl.textContent = line ? ((Math.abs(crossTrack)<0.005)? '0.00' : `${sign} ${Math.abs(crossTrack).toFixed(2)}`) : '--';
  subEl.textContent = `横ズレ: ${Math.abs(crossTrack).toFixed(2)} m / Aから: ${alongTrack.toFixed(1)} m`;
  draw();
}

function setState(text, cls='badge'){
  stateBadge.textContent = text;
  stateBadge.className = cls;
}

// ====== ログ ======
function addLog(c, spd, head, distA){
  if(!logging) return;
  log.push({
    t:new Date().toISOString(),
    lat:c.latitude, lon:c.longitude, acc:c.accuracy,
    speed:spd, heading:head,
    cross:crossTrack, along:alongTrack, distA:distA,
    abSet:!!line, gain:gain
  });
}
function downloadLog(){
  if(log.length===0){ alert('ログが空です'); return; }
  const header='t,lat,lon,acc_m,speed_mps,heading_deg,cross_m,along_m,distA_m,AB_set,gain\n';
  const rows=log.map(r => `${r.t},${r.lat},${r.lon},${r.acc ?? ''},${r.speed ?? ''},${r.heading ?? ''},${r.cross.toFixed(3)},${r.along.toFixed(3)},${r.distA.toFixed(3)},${r.abSet},${r.gain}`).join('\n');
  const blob=new Blob([header+rows],{type:'text/csv'});
  const a=document.createElement('a');
  a.href=URL.createObjectURL(blob);
  a.download=`straightbar_${new Date().toISOString().replace(/[:.]/g,'-')}.csv`;
  a.click();
  URL.revokeObjectURL(a.href);
}

// ====== B点：精度考慮の取得 ======
async function getFreshPositionForB({durationMs=2500, accLimit=12} = {}){
  return new Promise((resolve,reject)=>{
    const samples=[]; const start=Date.now(); let done=false;
    const wid=navigator.geolocation.watchPosition(
      p=>{
        const c=p.coords; samples.push(c);
        if(c.accuracy!=null && c.accuracy<=accLimit && !done){
          done=true; navigator.geolocation.clearWatch(wid); resolve(c);
        }else if(Date.now()-start>=durationMs && !done){
          done=true; navigator.geolocation.clearWatch(wid);
          let best=samples[0]||p.coords;
          for(const s of samples){ if(best.accuracy==null || (s.accuracy!=null && s.accuracy<best.accuracy)) best=s; }
          resolve(best);
        }
      },
      err=>{ if(!done){done=true; reject(err);} },
      {enableHighAccuracy:true, maximumAge:0, timeout:7000}
    );
  });
}

// ====== ボタン動作 ======
btnA.addEventListener('click', ()=>{
  if(!navigator.geolocation){ alert('Geolocation未対応'); return; }
  settingA=true; setState('A点設定中…','badge warn'); updateHeader({gpsOn:!!watchId});
  navigator.geolocation.getCurrentPosition(p=>{
    A_ll = {lat:p.coords.latitude, lon:p.coords.longitude};
    ref  = {lat:A_ll.lat, lon:A_ll.lon}; // ENU原点はA
    line = null; crossTrack=0; alongTrack=0;
    settingA=false; setState('A設定完了','badge'); updateHeader({gpsOn:!!watchId,acc:p.coords.accuracy});
  }, e=>{ settingA=false; setState('A取得失敗','badge bad'); alert('A取得失敗: '+e.message); },
  {enableHighAccuracy:true, maximumAge:0, timeout:7000});
});

btnB.addEventListener('click', async ()=>{
  if(!A_ll){ alert('先にA点を設定してください'); return; }
  settingB=true; setState('B点設定中…','badge warn'); updateHeader({gpsOn:!!watchId});
  try{
    const c = await getFreshPositionForB();
    B_ll = {lat:c.latitude, lon:c.longitude};
    const B = ll2enu(B_ll.lat, B_ll.lon, ref.lat, ref.lon); // A原点
    const v = [B[0], B[1]];
    const L = norm(v);
    const required = Math.max(5, (c.accuracy ?? 6) + 5); // 動的閾値
    if(L < required){
      settingB=false; setState('B距離不足','badge bad'); updateHeader({gpsOn:!!watchId,acc:c.accuracy});
      alert(`Aからの距離が不足: ${L.toFixed(1)}m（必要 ${required.toFixed(1)}m 目安）`);
      return;
    }
    const dir = normalize(v), nHat=[-dir[1], dir[0]];
    line = {p0:[0,0], dir, nHat, theta:Math.atan2(dir[1],dir[0])};
    crossTrack=0; alongTrack=0;
    settingB=false; setState('B設定完了','badge ok'); updateHeader({gpsOn:!!watchId,acc:c.accuracy});
  }catch(e){
    settingB=false; setState('B取得失敗','badge bad'); alert('B取得失敗: '+e.message);
  }
});

btnClear.addEventListener('click', ()=>{
  A_ll=null; B_ll=null; line=null; crossTrack=0; alongTrack=0;
  setState('待機中','badge muted'); updateHeader({gpsOn:!!watchId});
});

btnStart.addEventListener('click', ()=>{
  if(watchId!=null) return;
  if(!navigator.geolocation){ alert('Geolocation未対応'); return; }
  watchId = navigator.geolocation.watchPosition(p=>{
    const c=p.coords;
    // ヘッダー更新用
    const spd = (c.speed!=null && c.speed>0)? c.speed : 0;
    const head = (c.heading!=null && c.heading>=0)? c.heading : null;

    // ENU位置
    if(!ref) ref = {lat:c.latitude, lon:c.longitude};
    const e = ll2enu(c.latitude, c.longitude, ref.lat, ref.lon);

    if(line){
      const v=[e[0]-line.p0[0], e[1]-line.p0[1]];
      crossTrack = v[0]*line.nHat[0] + v[1]*line.nHat[1];
      alongTrack = v[0]*line.dir[0] + v[1]*line.dir[1];
    }else{
      crossTrack = 0; alongTrack = 0;
    }

    // ログ
    const distA = (A_ll ? haversine(A_ll.lat,A_ll.lon,c.latitude,c.longitude) : 0);
    addLog(c, spd, head, distA);

    updateHeader({gpsOn:true,acc:c.accuracy,spd:spd,head:head});
  }, e=>alert('位置失敗: '+e.message),
  {enableHighAccuracy:true, maximumAge:0, timeout:7000});
  setState('計測中','badge'); updateHeader({gpsOn:true});
});

btnStop.addEventListener('click', ()=>{
  if(watchId!=null){ navigator.geolocation.clearWatch(watchId); watchId=null; }
  setState('停止中','badge muted'); updateHeader({gpsOn:false});
});

// 感度
gainInp.addEventListener('change', ()=>{
  const g=parseFloat(gainInp.value||'2');
  gain = isFinite(g) ? Math.max(0.5, Math.min(10.0, g)) : 2.0;
  gainInp.value = gain.toFixed(1);
  draw();
});

// 画面常時ON（対応端末のみ）
btnWake.addEventListener('click', async ()=>{
  try{
    if(!('wakeLock' in navigator)){ alert('Wake Lock未対応端末'); return; }
    if(!window.__wakeLock){ window.__wakeLock = await navigator.wakeLock.request('screen'); btnWake.textContent='常時ON: 有効'; }
    else { await window.__wakeLock.release(); window.__wakeLock=null; btnWake.textContent='画面常時ON'; }
  }catch(e){ alert('Wake Lock失敗: '+e.message); }
});

// ログ操作
btnLogToggle.addEventListener('click', ()=>{
  logging = !logging;
  if(logging){ log = []; btnLogToggle.classList.add('on'); }
  else { btnLogToggle.classList.remove('on'); }
  btnLogToggle.textContent = logging ? 'ログ記録: ON' : 'ログ記録: OFF';
  updateHeader({gpsOn:!!watchId});
});
btnLogDownload.addEventListener('click', downloadLog);

// 初期表示
setState('待機中','badge muted');
updateHeader({gpsOn:false});
</script>
