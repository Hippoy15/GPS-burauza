<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>StraightBar Lite – Web</title>
<style>
  :root { color-scheme: dark; }
  body{margin:0;background:#0b0b0d;color:#ddd;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  header{padding:10px 14px;font-weight:600;display:flex;gap:10px;align-items:center;justify-content:space-between;background:#141419;border-bottom:1px solid #222}
  .stat{opacity:.9;font-size:.95rem;display:flex;gap:14px;flex-wrap:wrap}
  .wrap{padding:12px;display:flex;flex-direction:column;gap:12px;max-width:860px;margin:0 auto}
  .panel{background:#141419;border:1px solid #222;border-radius:12px;padding:16px}
  .big{font-size:52px;font-weight:800;letter-spacing:.5px}
  .hint{opacity:.8;margin-top:6px}
  .grid{background:#0f0f14;border-radius:12px;position:relative;height:240px;border:1px solid #222;overflow:hidden}
  canvas{position:absolute;inset:0}
  .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  button,input{font-size:16px;border-radius:10px;border:1px solid #2a2a2f;background:#1a1a22;color:#ddd;padding:10px 14px}
  button.primary{background:#2a5bff;border-color:#2a5bff;color:white}
  .badge{border:1px solid #333;padding:6px 10px;border-radius:999px;font-size:.9rem}
  .ok{color:#19c37d}.warn{color:#f5a524}.bad{color:#ef4444}
  .muted{opacity:.7}
</style>
</head>
<body>
<header>
  <div>StraightBar Lite – <span class="muted">Web</span></div>
  <div class="stat">
    <span id="statGps">GPS: -</span>
    <span id="statAcc">精度: -</span>
    <span id="statSpd">速度: -</span>
    <span id="statHead">針路: -</span>
    <span id="statAB" class="badge muted">A/B: 未設定</span>
  </div>
</header>

<div class="wrap">
  <!-- ガイダンス -->
  <div class="panel" id="guidance">
    <div style="display:flex;align-items:baseline;gap:14px;flex-wrap:wrap">
      <div id="dir" class="big">--</div>
      <div id="unit" style="font-size:22px;opacity:.85">m</div>
    </div>
    <div class="hint" id="sub">横ズレ: 0.00m / Aから: 0.0m / 沿線距離: 0.0m</div>
  </div>

  <!-- ビジュアル（固定センター線 + 可動線） -->
  <div class="grid"><canvas id="vis"></canvas></div>

  <!-- コントロール -->
  <div class="panel">
    <div class="row">
      <button class="primary" id="btnStart">計測開始</button>
      <button id="btnStop">停止</button>
      <button id="btnWake">画面常時ON</button>
      <span class="hint">（iPhoneは“ホーム画面に追加”推奨）</span>
    </div>

    <div class="row" style="margin-top:10px">
      <button id="btnA">A点 設定</button>
      <button id="btnB">B点 設定</button>
      <button id="btnClear">A/Bクリア</button>
      <label>スワス幅(m): <input type="number" id="swath" value="3" step="0.5" style="width:90px"></label>
      <span id="stateBadge" class="badge muted">待機中</span>
    </div>
  </div>
</div>

<script>
(() => {
  // ====== 状態 ======
  let watchId=null, accM=null, spd=0, courseDeg=null;
  let ref=null, A=null, line=null;
  let settingA=false, settingB=false;
  let targetIndex=0, swathW=3, crossTrack=0, headingErr=0, wakeLock=null;
  let distFromA=0, alongTrack=0;

  // ====== UI ======
  const statGps=document.getElementById('statGps');
  const statAcc=document.getElementById('statAcc');
  const statSpd=document.getElementById('statSpd');
  const statHead=document.getElementById('statHead');
  const statAB=document.getElementById('statAB');
  const stateBadge=document.getElementById('stateBadge');

  const dirEl=document.getElementById('dir');
  const subEl=document.getElementById('sub');

  const canvas=document.getElementById('vis');
  const ctx=canvas.getContext('2d');

  const btnStart=document.getElementById('btnStart');
  const btnStop=document.getElementById('btnStop');
  const btnWake=document.getElementById('btnWake');
  const btnA=document.getElementById('btnA');
  const btnB=document.getElementById('btnB');
  const btnClear=document.getElementById('btnClear');
  const swathInp=document.getElementById('swath');

  // ====== 数学 util ======
  const R=6378137.0;
  function ll2enu(lat,lon,refLat,refLon){
    const dLat=(lat-refLat)*Math.PI/180, dLon=(lon-refLon)*Math.PI/180;
    const mPerDegLat=Math.PI*R/180, mPerDegLon=mPerDegLat*Math.cos(refLat*Math.PI/180);
    return [dLon*mPerDegLon, dLat*mPerDegLat]; // [e, n]
  }
  const dot=(a,b)=>a[0]*b[0]+a[1]*b[1];
  const sub=(a,b)=>[a[0]-b[0],a[1]-b[1]];
  const norm=a=>Math.hypot(a[0],a[1]);
  const normalize=v=>{const L=norm(v)||1; return [v[0]/L,v[1]/L];}
  const angleWrap=x=>{while(x>Math.PI)x-=2*Math.PI;while(x<-Math.PI)x+=2*Math.PI;return x;}

  // ====== Canvas ======
  function resize(){ canvas.width=canvas.clientWidth; canvas.height=canvas.clientHeight; draw(); }
  window.addEventListener('resize', resize); resize();

  function draw(){
    const w=canvas.width,h=canvas.height;
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle='#0f0f14'; ctx.fillRect(0,0,w,h);

    // 背景グリッド
    ctx.strokeStyle='#202028'; ctx.lineWidth=1;
    for(let i=0;i<6;i++){ const x=i*w/6; ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }

    // 表示レンジ（横方向の±rangeMを映す）
    const rangeM=Math.max(3, swathW*1.5);
    const pxPerM=w/(rangeM*2);

    // 1) 基準センター線（固定）
    const centerX=w/2;
    ctx.strokeStyle='#38bdf8'; ctx.lineWidth=3;
    ctx.beginPath(); ctx.moveTo(centerX,0); ctx.lineTo(centerX,h); ctx.stroke();

    // 2) 可動線（横ズレに比例して動く）
    let moveX = centerX + crossTrack * pxPerM; // 右(+) / 左(-)
    // はみ出しを抑制（見える範囲にクランプ）
    moveX = Math.max(0, Math.min(w, moveX));

    const absE = Math.abs(crossTrack);
    ctx.strokeStyle = absE<=0.10 ? '#19c37d' : (absE<=0.30 ? '#f5a524' : '#ef4444'); // 10cm/30cm
    ctx.lineWidth=5;
    ctx.beginPath(); ctx.moveTo(moveX,0); ctx.lineTo(moveX,h); ctx.stroke();

    // 側面インジケータ
    ctx.fillStyle = ctx.strokeStyle;
    ctx.fillRect(w-8, 0, 8, h);
  }

  // ====== UI更新 ======
  function updatePanels(){
    statGps.textContent = watchId?'GPS: 取得中':'GPS: -';
    statAcc.textContent = '精度: '+(accM==null?'-':`${accM.toFixed(0)}m`);
    statSpd.textContent = '速度: '+(spd?(spd*3.6).toFixed(1)+'km/h':'-');
    statHead.textContent= '針路: '+(courseDeg==null?'-':`${courseDeg.toFixed(0)}°`);

    // A/B状態
    if(settingA) { statAB.textContent='A/B: A点設定中'; statAB.className='badge warn'; }
    else if(settingB) { statAB.textContent='A/B: B点設定中'; statAB.className='badge warn'; }
    else if(line) { statAB.textContent='A/B: 設定済'; statAB.className='badge ok'; }
    else if(A) { statAB.textContent='A/B: Aのみ設定'; statAB.className='badge'; }
    else { statAB.textContent='A/B: 未設定'; statAB.className='badge muted'; }

    // 大表示（横ズレ）
    const sign = crossTrack>0?'左へ':(crossTrack<0?'右へ':'そのまま');
    dirEl.textContent = (line? ((crossTrack===0)? '0.00' : `${sign} ${Math.abs(crossTrack).toFixed(2)}`) : '--');

    // 補足：横ズレ + Aから距離 + 沿線距離
    subEl.textContent = `横ズレ: ${Math.abs(crossTrack).toFixed(2)} m / Aから: ${distFromA.toFixed(1)} m / 沿線距離: ${alongTrack.toFixed(1)} m`;

    draw();
  }

  // ====== 計測開始/停止 ======
  btnStart.addEventListener('click', ()=>{
    if(watchId!=null) return;
    if(!navigator.geolocation){ alert('Geolocation未対応'); return; }
    watchId = navigator.geolocation.watchPosition(p=>{
      const c=p.coords;
      if(!ref) ref={lat:c.latitude, lon:c.longitude};
      accM=c.accuracy??null;
      spd=(c.speed!=null&&c.speed>0)?c.speed:0;
      courseDeg=(c.heading!=null&&c.heading>=0)?c.heading:null;

      const pt=ll2enu(c.latitude,c.longitude,ref.lat,ref.lon);

      // Aからの距離（直線距離）
      if(A){ distFromA = norm( sub(pt, A) ); }
      else { distFromA = 0; }

      if(line){
        // 横ズレ（法線方向）
        const p0t=[ line.p0[0]+line.nHat[0]*targetIndex*swathW, line.p0[1]+line.nHat[1]*targetIndex*swathW ];
        crossTrack = dot( sub(pt,p0t), line.nHat ); // m
        // 沿線距離（直線方向の進み）
        alongTrack = dot( sub(pt,line.p0), line.dir ); // m
        // 方位誤差（参考）
        const thetaVeh = (courseDeg!=null)? courseDeg*Math.PI/180 : 0;
        headingErr = angleWrap(thetaVeh - line.theta);
      } else {
        crossTrack = 0;
        alongTrack = 0;
      }
      updatePanels();
    }, e=>alert('位置失敗: '+e.message),
       {enableHighAccuracy:true, maximumAge:0, timeout:5000});
    stateBadge.textContent='計測中'; stateBadge.className='badge';
    updatePanels();
  });

  btnStop.addEventListener('click', ()=>{
    if(watchId!=null){ navigator.geolocation.clearWatch(watchId); watchId=null; }
    stateBadge.textContent='停止中'; stateBadge.className='badge muted';
    updatePanels();
  });

  // ====== A/B設定 ======
  btnA.addEventListener('click', ()=>{
    if(!watchId){ alert('先に「計測開始」を押してください'); return; }
    settingA=true; settingB=false; updatePanels();
    navigator.geolocation.getCurrentPosition(p=>{
      // Aを現在地にし、座標原点＆参照もAへ
      ref={lat:p.coords.latitude, lon:p.coords.longitude};
      A = ll2enu(ref.lat, ref.lon, ref.lat, ref.lon); // (0,0)
      line=null; targetIndex=0; crossTrack=0; alongTrack=0; distFromA=0;
      settingA=false; updatePanels();
    }, e=>{ settingA=false; updatePanels(); alert('A取得失敗: '+e.message); }, {enableHighAccuracy:true});
  });

  btnB.addEventListener('click', ()=>{
    if(!A){ alert('先にA点を設定してください'); return; }
    settingB=true; updatePanels();
    navigator.geolocation.getCurrentPosition(p=>{
      const B=ll2enu(p.coords.latitude, p.coords.longitude, ref.lat, ref.lon);
      const v=[B[0]-A[0], B[1]-A[1]];
      const L=norm(v);
      if(L<1){ settingB=false; updatePanels(); alert('AとBが近すぎ'); return; }
      const dir=normalize(v); const nHat=[-dir[1], dir[0]];
      const theta=Math.atan2(dir[1], dir[0]);
      line={p0:[A[0],A[1]], dir, nHat, theta};
      targetIndex=0; crossTrack=0; alongTrack=0;
      settingB=false; updatePanels();
    }, e=>{ settingB=false; updatePanels(); alert('B取得失敗: '+e.message); }, {enableHighAccuracy:true});
  });

  btnClear.addEventListener('click', ()=>{
    line=null; A=null; crossTrack=0; alongTrack=0; distFromA=0;
    stateBadge.textContent='待機中'; stateBadge.className='badge muted';
    updatePanels();
  });

  // ====== スワス幅 ======
  swathInp.addEventListener('change', ()=>{
    swathW=Math.max(0.1, parseFloat(swathInp.value||'3')); updatePanels();
  });

  // ====== 画面常時ON ======
  btnWake.addEventListener('click', async ()=>{
    try{
      if(!('wakeLock' in navigator)){ alert('Wake Lock未対応端末。iPhoneは省電力設定に注意'); return; }
      if(!wakeLock){ wakeLock=await navigator.wakeLock.request('screen'); btnWake.textContent='常時ON: 有効'; }
      else { await wakeLock.release(); wakeLock=null; btnWake.textContent='画面常時ON'; }
    }catch(e){ alert('Wake Lock失敗: '+e.message); }
  });

  updatePanels();
})();
</script>
</body>
</html>
