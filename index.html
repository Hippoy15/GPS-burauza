<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>StraightBar Lite – Web</title>
<style>
  :root { color-scheme: dark; }
  body{margin:0;background:#0b0b0d;color:#ddd;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  header{padding:10px 14px;font-weight:600;display:flex;gap:10px;align-items:center;justify-content:space-between;background:#141419;border-bottom:1px solid #222}
  .stat{opacity:.9;font-size:.95rem;display:flex;gap:14px;flex-wrap:wrap}
  .wrap{padding:12px;display:flex;flex-direction:column;gap:12px;max-width:860px;margin:0 auto}
  .panel{background:#141419;border:1px solid #222;border-radius:12px;padding:16px}
  .big{font-size:52px;font-weight:800;letter-spacing:.5px}
  .hint{opacity:.8;margin-top:6px}
  .grid{background:#0f0f14;border-radius:12px;position:relative;height:260px;border:1px solid #222;overflow:hidden}
  canvas{position:absolute;inset:0}
  .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  button,input{font-size:16px;border-radius:10px;border:1px solid #2a2a2f;background:#1a1a22;color:#ddd;padding:10px 14px}
  button.primary{background:#2a5bff;border-color:#2a5bff;color:white}
  input[type="number"]{width:90px}
  .badge{border:1px solid #333;padding:6px 10px;border-radius:999px;font-size:.9rem}
  .ok{color:#19c37d}.warn{color:#f5a524}.bad{color:#ef4444}.muted{opacity:.7}
  .on{background:#19c37d;border-color:#19c37d;color:#0b0b0d}
</style>
</head>
<body>
<header>
  <div>StraightBar Lite – <span class="muted">Web</span></div>
  <div class="stat">
    <span id="statGps">GPS: -</span>
    <span id="statAcc">精度: -</span>
    <span id="statSpd">速度: -</span>
    <span id="statHead">針路: -</span>
    <span id="statAB" class="badge muted">A/B: 未設定</span>
    <span id="statABlen" class="badge muted">AB距離: -</span>
    <span id="statLog" class="badge muted">LOG: 0点</span>
  </div>
</header>

<div class="wrap">
  <!-- ガイダンス -->
  <div class="panel">
    <div style="display:flex;align-items:baseline;gap:14px;flex-wrap:wrap">
      <div id="dir" class="big">--</div>
      <div id="unit" style="font-size:22px;opacity:.85">m</div>
    </div>
    <div class="hint" id="sub">横ズレ: 0.00m / Aから: 0.0m / 沿線距離: 0.0m</div>
  </div>

  <!-- 可視化（中央固定線 + 可動線のみ） -->
  <div class="grid"><canvas id="vis"></canvas></div>

  <!-- 操作 -->
  <div class="panel">
    <div class="row">
      <button class="primary" id="btnStart">計測開始</button>
      <button id="btnStop">停止</button>
      <button id="btnWake">画面常時ON</button>
      <label>感度(gain):
        <input type="number" id="gain" value="2.0" step="0.1" />
      </label>
      <span id="stateBadge" class="badge muted">待機中</span>
    </div>
    <div class="row" style="margin-top:10px">
      <button id="btnA">A点 設定</button>
      <button id="btnB">B点 設定</button>
      <button id="btnClear">A/Bクリア</button>
      <button id="logToggle">ログ記録: OFF</button>
      <button id="logDownload">CSVダウンロード</button>
    </div>
  </div>
</div>

<script>
(() => {
  // ====== 状態 ======
  let watchId=null, accM=null, spd=0, courseDeg=null;
  let ref=null;               // ENU原点（A設定時にAへ）
  let A=null, A_ll=null;      // A（ENU座標）, Aの緯度経度
  let B_ll=null;              // Bの緯度経度（参考表示）
  let line=null;              // {p0:[e,n], dir:[x,y], nHat:[x,y], theta}
  let settingA=false, settingB=false;
  let crossTrack=0, alongTrack=0, distFromA=0;
  let wakeLock=null, gain=2.0;

  // ログ
  let logging=false;
  let log=[];

  // ====== UI ======
  const statGps=document.getElementById('statGps');
  const statAcc=document.getElementById('statAcc');
  const statSpd=document.getElementById('statSpd');
  const statHead=document.getElementById('statHead');
  const statAB=document.getElementById('statAB');
  const statABlen=document.getElementById('statABlen');
  const statLog=document.getElementById('statLog');

  const stateBadge=document.getElementById('stateBadge');
  const dirEl=document.getElementById('dir');
  const subEl=document.getElementById('sub');

  const canvas=document.getElementById('vis');
  const ctx=canvas.getContext('2d');

  const btnStart=document.getElementById('btnStart');
  const btnStop=document.getElementById('btnStop');
  const btnWake=document.getElementById('btnWake');
  const btnA=document.getElementById('btnA');
  const btnB=document.getElementById('btnB');
  const btnClear=document.getElementById('btnClear');
  const gainInp=document.getElementById('gain');

  const btnLogToggle=document.getElementById('logToggle');
  const btnLogDownload=document.getElementById('logDownload');

  // ====== 数学 util ======
  const R=6378137.0;
  const toRad = d => d*Math.PI/180;
  function ll2enu(lat,lon,refLat,refLon){
    const dLat=(lat-refLat)*Math.PI/180, dLon=(lon-refLon)*Math.PI/180;
    const mPerDegLat=Math.PI*R/180, mPerDegLon=mPerDegLat*Math.cos(refLat*Math.PI/180);
    return [dLon*mPerDegLon, dLat*mPerDegLat]; // [e, n]
  }
  // ハバースイン：Aからの地表直線距離[m]
  function haversine(lat1,lon1,lat2,lon2){
    const dLat=toRad(lat2-lat1), dLon=toRad(lon2-lon1);
    const s1=Math.sin(dLat/2), s2=Math.sin(dLon/2);
    const a=s1*s1 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*s2*s2;
    return 2*6371000*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  }
  const dot=(a,b)=>a[0]*b[0]+a[1]*b[1];
  const sub=(a,b)=>[a[0]-b[0],a[1]-b[1]];
  const norm=a=>Math.hypot(a[0],a[1]);
  const normalize=v=>{const L=norm(v)||1; return [v[0]/L,v[1]/L];}
  const angleWrap=x=>{while(x>Math.PI)x-=2*Math.PI;while(x<-Math.PI)x+=2*Math.PI;return x;}

  // ====== Canvas ======
  function resize(){ canvas.width=canvas.clientWidth; canvas.height=canvas.clientHeight; draw(); }
  window.addEventListener('resize', resize); resize();

  function draw(){
    const w=canvas.width,h=canvas.height;
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle='#0f0f14'; ctx.fillRect(0,0,w,h);

    // 背景の薄い縦ガイド
    ctx.strokeStyle='#202028'; ctx.lineWidth=1;
    for(let i=0;i<6;i++){ const x=i*w/6; ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }

    // 表示レンジ（px/ｍ）
    const rangeM=6; // 片側6mまでを基準（感度で見え方調整）
    const pxPerM=w/(rangeM*2);

    // 中央の固定ライン（水色・太め）
    const centerX=w/2;
    ctx.strokeStyle='#38bdf8'; ctx.lineWidth=6;
    ctx.beginPath(); ctx.moveTo(centerX,0); ctx.lineTo(centerX,h); ctx.stroke();

    // 可動ライン（横ズレ×感度で移動、色は誤差に応じて）
    let moveX=centerX + (crossTrack*gain)*pxPerM;
    moveX=Math.max(0, Math.min(w, moveX)); // 可視範囲にクランプ
    const absE=Math.abs(crossTrack);
    const color = absE<=0.10 ? '#19c37d' : (absE<=0.30 ? '#f5a524' : '#ef4444'); // 10cm/30cm
    ctx.strokeStyle=color; ctx.lineWidth=10;
    ctx.beginPath(); ctx.moveTo(moveX,0); ctx.lineTo(moveX,h); ctx.stroke();
  }

  // ====== UI更新 ======
  function updatePanels(){
    statGps.textContent = watchId?'GPS: 取得中':'GPS: -';
    statAcc.textContent = '精度: '+(accM==null?'-':`${accM.toFixed(0)}m`);
    statSpd.textContent = '速度: '+(spd?(spd*3.6).toFixed(1)+'km/h':'-');
    statHead.textContent= '針路: '+(courseDeg==null?'-':`${courseDeg.toFixed(0)}°`);

    if(settingA){ statAB.textContent='A/B: A点設定中'; statAB.className='badge warn'; }
    else if(settingB){ statAB.textContent='A/B: B点設定中'; statAB.className='badge warn'; }
    else if(line){ statAB.textContent='A/B: 設定済'; statAB.className='badge ok'; }
    else if(A_ll){ statAB.textContent='A/B: Aのみ設定'; statAB.className='badge'; }
    else { statAB.textContent='A/B: 未設定'; statAB.className='badge muted'; }

    const showABLen = (A_ll && B_ll) ? `${(haversine(A_ll.lat,A_ll.lon,B_ll.lat,B_ll.lon)).toFixed(1)} m` : '-';
    statABlen.textContent = 'AB距離: ' + showABLen;

    statLog.textContent = `LOG: ${log.length}点`;
    statLog.className = 'badge ' + (logging ? 'ok' : 'muted');

    // 大表示（横ズレ）
    const sign = crossTrack>0?'左へ':(crossTrack<0?'右へ':'そのまま');
    dirEl.textContent = line ? ((Math.abs(crossTrack)<0.005)? '0.00' : `${sign} ${Math.abs(crossTrack).toFixed(2)}`) : '--';

    // 補足
    subEl.textContent = `横ズレ: ${Math.abs(crossTrack).toFixed(2)} m / Aから: ${distFromA.toFixed(1)} m / 沿線距離: ${alongTrack.toFixed(1)} m`;

    draw();
  }

  // ====== 計測開始/停止 ======
  btnStart.addEventListener('click', ()=>{
    if(watchId!=null) return;
    if(!navigator.geolocation){ alert('Geolocation未対応'); return; }
    watchId = navigator.geolocation.watchPosition(p=>{
      const c=p.coords;
      accM=c.accuracy??null;
      spd=(c.speed!=null&&c.speed>0)?c.speed:0;
      courseDeg=(c.heading!=null&&c.heading>=0)?c.heading:null;

      // 参照（ENU原点）が未設定なら現在地で仮セット（A設定で上書き）
      if(!ref) ref={lat:c.latitude, lon:c.longitude};

      // ENU座標
      const pt=ll2enu(c.latitude,c.longitude,ref.lat,ref.lon);

      // Aからの地表直線距離
      if(A_ll){ distFromA = haversine(A_ll.lat, A_ll.lon, c.latitude, c.longitude); }
      else { distFromA = 0; }

      if(line){
        crossTrack = dot( sub(pt,line.p0), line.nHat ); // 法線方向のズレ
        alongTrack = dot( sub(pt,line.p0), line.dir );  // 直線方向の進み
      } else {
        crossTrack = 0; alongTrack = 0;
      }

      // ログ記録
      if (logging) {
        log.push({
          t: new Date().toISOString(),
          lat: c.latitude,
          lon: c.longitude,
          acc: c.accuracy,
          speed: spd,
          heading: courseDeg,
          cross: crossTrack,
          along: alongTrack,
          distA: distFromA,
          abSet: !!line,
          gain: gain
        });
      }

      updatePanels();
    }, e=>alert('位置失敗: '+e.message),
       {enableHighAccuracy:true, maximumAge:0, timeout:7000});
    stateBadge.textContent='計測中'; stateBadge.className='badge';
    updatePanels();
  });

  btnStop.addEventListener('click', ()=>{
    if(watchId!=null){ navigator.geolocation.clearWatch(watchId); watchId=null; }
    stateBadge.textContent='停止中'; stateBadge.className='badge muted';
    updatePanels();
  });

  // ====== A/B設定 ======
  btnA.addEventListener('click', ()=>{
    if(!watchId){ alert('先に「計測開始」を押してください'); return; }
    settingA=true; settingB=false; updatePanels();
    navigator.geolocation.getCurrentPosition(p=>{
      A_ll = {lat:p.coords.latitude, lon:p.coords.longitude}; // Aの緯度経度
      ref = {lat:A_ll.lat, lon:A_ll.lon}; // ENU原点をAへ
      A = [0,0];
      line=null; crossTrack=0; alongTrack=0; distFromA=0;
      settingA=false; updatePanels();
    }, e=>{ settingA=false; updatePanels(); alert('A取得失敗: '+e.message); },
       {enableHighAccuracy:true, maximumAge:0, timeout:7000});
  });

  btnB.addEventListener('click', ()=>{
    if(!A_ll){ alert('先にA点を設定してください'); return; }
    settingB=true; updatePanels();
    navigator.geolocation.getCurrentPosition(p=>{
      B_ll = {lat:p.coords.latitude, lon:p.coords.longitude};
      const B = ll2enu(B_ll.lat, B_ll.lon, ref.lat, ref.lon); // refはA
      const v=[B[0]-A[0], B[1]-A[1]];
      const L=norm(v);
      if(L<3){ settingB=false; updatePanels(); alert('AとBが近すぎ（3m以上推奨）'); return; }
      const dir=normalize(v); const nHat=[-dir[1], dir[0]];
      const theta=Math.atan2(dir[1], dir[0]);
      line={p0:[A[0],A[1]], dir, nHat, theta};
      crossTrack=0; alongTrack=0;
      settingB=false; updatePanels();
    }, e=>{ settingB=false; updatePanels(); alert('B取得失敗: '+e.message); },
       {enableHighAccuracy:true, maximumAge:0, timeout:7000});
  });

  btnClear.addEventListener('click', ()=>{
    line=null; A=null; A_ll=null; B_ll=null; crossTrack=0; alongTrack=0; distFromA=0;
    stateBadge.textContent='待機中'; stateBadge.className='badge muted';
    updatePanels();
  });

  // 感度
  gainInp.addEventListener('change', ()=>{
    const g=parseFloat(gainInp.value||'2');
    gain = isFinite(g) ? Math.max(0.5, Math.min(4.0, g)) : 2.0;
    gainInp.value = gain.toFixed(1);
    draw();
  });

  // 画面常時ON
  btnWake.addEventListener('click', async ()=>{
    try{
      if(!('wakeLock' in navigator)){ alert('Wake Lock未対応端末。iPhoneは省電力設定に注意'); return; }
      if(!wakeLock){ wakeLock=await navigator.wakeLock.request('screen'); btnWake.textContent='常時ON: 有効'; }
      else { await wakeLock.release(); wakeLock=null; btnWake.textContent='画面常時ON'; }
    }catch(e){ alert('Wake Lock失敗: '+e.message); }
  });

  // ログ操作
  btnLogToggle.addEventListener('click', ()=>{
    logging = !logging;
    if (logging) { log = []; btnLogToggle.classList.add('on'); }
    else { btnLogToggle.classList.remove('on'); }
    btnLogToggle.textContent = logging ? 'ログ記録: ON' : 'ログ記録: OFF';
    updatePanels();
  });

  btnLogDownload.addEventListener('click', ()=>{
    if (log.length===0) { alert('ログが空です'); return; }
    const header = 't,lat,lon,acc_m,speed_mps,heading_deg,cross_m,along_m,distA_m,AB_set,gain\n';
    const rows = log.map(r =>
      `${r.t},${r.lat},${r.lon},${r.acc ?? ''},${r.speed ?? ''},${r.heading ?? ''},` +
      `${r.cross.toFixed(3)},${r.along.toFixed(3)},${r.distA.toFixed(3)},${r.abSet},${r.gain}`
    ).join('\n');
    const blob = new Blob([header + rows], {type: 'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `straightbar_${new Date().toISOString().replace(/[:.]/g,'-')}.csv`;
    a.click();
    URL.revokeObjectURL(a.href);
  });

  updatePanels();
})();
</script>
</body>
</html>
